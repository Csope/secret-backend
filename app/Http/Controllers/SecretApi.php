<?php

/**
 * Secret Server
 * This is an API of a secret service. You can save your secret by using the API. You can restrict the access of a secret after the certen number of views or after a certen period of time.
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


namespace App\Http\Controllers;

use App\Secret;
use Carbon\Carbon;
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Support\Facades\Request;
use Illuminate\Support\Facades\Validator;
use Illuminate\Validation\Rule;

class SecretApi extends Controller
{

    protected $headers =  [ 
            'Access-Control-Allow-Origin'      => '*',
            'Access-Control-Allow-Methods'     => 'POST, GET, OPTIONS, PUT, DELETE',
            'Access-Control-Allow-Credentials' => 'true',
            'Access-Control-Max-Age'           => '86400',
            'Access-Control-Allow-Headers'     => 'Content-Type, Authorization, X-Requested-With'
        ];

    /**
     * Constructor
     */
    public function __construct()
    {
    }


    /**
     * Operation addSecret
     *
     * Add a new secret.
     *
     *
     * @return Http response
     */
    public function addSecret()
    {

        $input = Request::all();
     
        if (!isset($input['expire_after']) || $input['expire_after'] == '0'  || $input['expire_after'] == '') {
            $input['expire_after'] = NULL;
        }

        $validator = $this->validator($input);

        if ($validator->fails()) {
            return $this->respondWithError($validator->errors());
        }

        $secret = new Secret;
        $secret->secretText = $input['secret'];
        $secret->remainingViews = $input['expire_after_views'];
        $secret->expiresAt = $input['expire_after'];
        $secret->hash = hash('sha256',md5($secret.time()));
        $secret->save();


        return $this->respond($secret);

    }


    /**
     * Operation getSecretByHash
     *
     * Find a secret by hash.
     *
     * @param string $hash Unique hash to identify the secret (required)
     *
     * @return Http response
     */
    public function getSecretByHash($hash)
    {
        $input = Request::all();
  
        $secret = Secret::where('hash', $hash)
                        ->where('remainingViews', '>', 0)
                        ->where(function (Builder $query) {
                            $query->where('expiresAt', '>=', Carbon::now())
                                  ->orWhere('expiresAt', null);
                        })
                        ->first();


        if(!$secret) {
            return $this->respondWithError('Secret not found', 404);
        }

        $secret->remainingViews--;
        $secret->save();

        return $this->respond($secret);
    }


    /**
     * Handles an error response formatting it according to our spec.
     *
     * @param array $error
     * @param int $statuscode
     * @return \Symfony\Component\HttpFoundation\Response
     */
    protected function respondWithError($error, $statuscode = 405)
    {
        return response()->json(['errors' => $error],
            $statuscode,
            $this->headers
        )->setStatusCode($statuscode);
    }

    
    /**
     * Handle response
     * @param  \App\Secret $secret 
     * @return \Symfony\Component\HttpFoundation\Response
     */
    protected function respond($secret) 
    {

         return response()->json(
            [
                "hash" => $secret->hash,
                "secretText" => $secret->secretText,
                "createdAt" => $secret->createdAt,
                "expiresAt" => $secret->expiresAt,
                "remainingViews" => $secret->remainingViews
            ],
            200,
            $this->headers
         )->setStatusCode(200);

    }
   

   /**
    * Validate the inputs
    * @param  array $data [description]
    * @return Illuminate\Support\Facades\Validator
    */
   private function validator($data)
    {

        return Validator::make($data, [
          'secret' => 'required',
          'expire_after_views' => 'required|integer',
          'expire_after' => 'nullable|date'
        ]);
    }



}
